package envcfg

// Code generated by internal/cmd/gen/gen.go DO NOT EDIT.

import (
	"errors"
	"strings"
	"time"
)

// Duration extracts and parses a time.Duration variable using the options provided.
//
// The first argument must be a string with beginning with the variable name as expected in the process environment.
// Any other options -- none of which are required -- may either be specified in the remainder of the string or using
// the type-safe DurationOpts.
//
// Available options:
// 		- "default" or DurationDefault
// 		- "optional" or Optional
func (c *Cfg) Duration(docOpts string, opts ...DurationOpt) (v time.Duration) {
	s, err := newDurationSpec(docOpts, opts)
	if err != nil {
		if c.panic {
			panic(err)
		}
		c.addError(err)
		return
	}
	c.addDescription(s.describe())
	v, _ = c.evaluate(s).(time.Duration)
	return
}

// DurationOpt modifies Duration variable configuration.
type DurationOpt interface {
	modify(s *spec)
	modifyDurationParser(p *durationParser)
}

// DurationDefault specifies a default value for a Duration variable.
func DurationDefault(def time.Duration) DurationOpt {
	return defaultOpt(def)
}

type durationOptFunc func(p *durationParser)

func (f durationOptFunc) modifyDurationParser(p *durationParser) {
	f(p)
}

func (durationOptFunc) modify(*spec) {}

var _ DurationOpt = new(durationOptFunc)

func newDurationSpec(docOpts string, opts []DurationOpt) (*spec, error) {
	parsed, err := parse(docOpts)
	if err != nil {
		return nil, err
	}

	p := new(durationParser)
	s := &spec{
		parser:   p,
		typeName: "time.Duration",
		name:     parsed.name,
		comment:  parsed.description,
	}

	for _, f := range parsed.fields {
		var (
			opt DurationOpt
			err error
		)
		switch strings.ToLower(f[0]) {
		case "default":
			val := f[1]
			opt = uniOptFunc(func(s *spec) {
				s.flags |= flagDefaultValString | flagDefaultVal
				s.defaultValS = val
			})
		case "optional":
			if f[1] != "" {
				err = errors.New("optional does not take any arguments")
			}
			opt = Optional
		}
		if err != nil {
			return nil, err
		}
		if opt == nil {
			return nil, errors.New("unknown")
		}
		opt.modify(s)
		opt.modifyDurationParser(p)
	}

	for _, opt := range opts {
		opt.modify(s)
		opt.modifyDurationParser(p)
	}

	if s.flags&flagDefaultValString > 0 {
		if s.defaultVal, err = p.parse(s.defaultValS); err != nil {
			return nil, err
		}
	}

	return s, nil
}

type durationParser struct {
}

func (p *durationParser) parse(s string) (interface{}, error) {
	return time.ParseDuration(
		s,
	)
}

func (p *durationParser) describe() interface{} {
	return struct{}{}
}
