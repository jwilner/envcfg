// Code generated by internal/cmd/gen/gen.go DO NOT EDIT.
package envcfg

import (
	"errors"
	"strconv"
	"strings"
)

// Uint extracts and parses the variable provided according to the options provided.
// Available options:
// - base
// - bit_size
// - default
// - optional
func (c *Cfg) Uint(docOpts string, opts ...UintOpt) (v uint64) {
	s, err := newUintSpec(docOpts, opts)
	if err != nil {
		if c.panic {
			panic(err)
		}
		c.addError(err)
		return
	}
	c.addDescription(s.describe())
	v, _ = c.evaluate(s).(uint64)
	return
}

// UintOpt modifies Uint variable configuration.
type UintOpt interface {
	modify(s *spec)
	modifyUintParser(p *uintParser)
}

var Uint = struct {
	Base    func(int) UintOpt
	BitSize func(int) UintOpt
	Default func(uint64) UintOpt
}{
	Base: func(base int) UintOpt {
		return uintOptFunc(func(p *uintParser) {
			p.setBase(base)
		})
	},
	BitSize: func(bitSize int) UintOpt {
		return uintOptFunc(func(p *uintParser) {
			p.setBitSize(bitSize)
		})
	},
	Default: func(def uint64) UintOpt {
		return defaultOpt(def)
	},
}

type uintOptFunc func(p *uintParser)

func (f uintOptFunc) modifyUintParser(p *uintParser) {
	f(p)
}

func (uintOptFunc) modify(*spec) {}

var _ UintOpt = new(uintOptFunc)

func newUintSpec(docOpts string, opts []UintOpt) (*spec, error) {
	parsed, err := parse(docOpts)
	if err != nil {
		return nil, err
	}

	p := new(uintParser)
	s := &spec{
		parser:   p,
		typeName: "uint64",
		name:     parsed.name,
		comment:  parsed.description,
	}

	for _, f := range parsed.fields {
		var (
			opt UintOpt
			err error
		)
		switch strings.ToLower(f[0]) {
		case "base":
			var val int
			val, err = strconv.Atoi(f[1])
			opt = Uint.Base(val)
		case "bit_size":
			var val int
			val, err = strconv.Atoi(f[1])
			opt = Uint.BitSize(val)
		case "default":
			val := f[1]
			opt = uniOptFunc(func(s *spec) {
				s.flags |= flagDefaultValString | flagDefaultVal
				s.defaultValS = val
			})
		case "optional":
			if f[1] != "" {
				err = errors.New("optional does not take any arguments")
			}
			opt = Optional
		}
		if err != nil {
			return nil, err
		}
		if opt == nil {
			return nil, errors.New("unknown")
		}
		opt.modify(s)
		opt.modifyUintParser(p)
	}

	for _, opt := range opts {
		opt.modify(s)
		opt.modifyUintParser(p)
	}

	if s.flags&flagDefaultValString > 0 {
		if s.defaultVal, err = p.parse(s.defaultValS); err != nil {
			return nil, err
		}
	}

	return s, nil
}

type uintParser struct {
	base    int
	bitSize int
}

func (p *uintParser) setBase(base int) {
	p.base = base
}

func (p *uintParser) setBitSize(bitSize int) {
	p.bitSize = bitSize
}

func (p *uintParser) parse(s string) (interface{}, error) {
	return strconv.ParseUint(
		s,
		p.base,
		p.bitSize,
	)
}

func (p *uintParser) describe() interface{} {
	return uintParserDescription{
		Base:    p.base,
		BitSize: p.bitSize,
	}
}

type uintParserDescription struct {
	Base    int `json:"base,omitempty"`
	BitSize int `json:"bit_size,omitempty"`
}
