// Code generated by internal/cmd/gen/gen.go DO NOT EDIT.
package envcfg

import (
	"time"
)

type Configurer interface {
	Has(s string) bool
	HasNot(s string) bool
	Bool(docOpts string, opts ...BoolOpt) bool
	Duration(docOpts string, opts ...DurationOpt) time.Duration
	Float(docOpts string, opts ...FloatOpt) float64
	Int(docOpts string, opts ...IntOpt) int64
	IntSlice(docOpts string, opts ...IntSliceOpt) []int64
	String(docOpts string, opts ...StringOpt) string
	StringSlice(docOpts string, opts ...StringSliceOpt) []string
	Time(docOpts string, opts ...TimeOpt) time.Time
	Uint(docOpts string, opts ...UintOpt) uint64
}

type UniOpt interface {
	modify(s *spec) error
	modifyBoolParser(p *boolParser) error
	modifyDurationParser(p *durationParser) error
	modifyFloatParser(p *floatParser) error
	modifyIntParser(p *intParser) error
	modifyIntSliceParser(p *intSliceParser) error
	modifyStringParser(p *stringParser) error
	modifyStringSliceParser(p *stringSliceParser) error
	modifyTimeParser(p *timeParser) error
	modifyUintParser(p *uintParser) error
}

type uniOptFunc func(s *spec) error

func (f uniOptFunc) modify(s *spec) error {
	return f(s)
}

func (uniOptFunc) modifyBoolParser(p *boolParser) error {
	return nil
}

func (uniOptFunc) modifyDurationParser(p *durationParser) error {
	return nil
}

func (uniOptFunc) modifyFloatParser(p *floatParser) error {
	return nil
}

func (uniOptFunc) modifyIntParser(p *intParser) error {
	return nil
}

func (uniOptFunc) modifyIntSliceParser(p *intSliceParser) error {
	return nil
}

func (uniOptFunc) modifyStringParser(p *stringParser) error {
	return nil
}

func (uniOptFunc) modifyStringSliceParser(p *stringSliceParser) error {
	return nil
}

func (uniOptFunc) modifyTimeParser(p *timeParser) error {
	return nil
}

func (uniOptFunc) modifyUintParser(p *uintParser) error {
	return nil
}

var _ UniOpt = new(uniOptFunc)

type BoolOpt interface {
	modifyBoolParser(p *boolParser) error
}

type boolOptFunc func(p *boolParser) error

func (f boolOptFunc) modifyBoolParser(p *boolParser) error {
	return f(p)
}

var _ BoolOpt = new(boolOptFunc)

func newBoolSpec(docOpts string, opts []BoolOpt) (*spec, error) {
	parsed, err := parseDocOpts(docOpts)
	if err != nil {
		return nil, err
	}

	os := make([]BoolOpt, 0, len(opts)+len(parsed))
	for _, p := range parsed {
		os = append(os, p)
	}

	p := new(boolParser)
	s := &spec{
		parser:   p,
		typeName: "bool",
	}

	for _, opt := range append(os, opts...) {
		if opt, ok := opt.(interface{ modify(*spec) error }); ok {
			if err = opt.modify(s); err != nil {
				return nil, err
			}
			continue
		}
		if err := opt.modifyBoolParser(p); err != nil {
			return nil, err
		}
	}

	if s.flags&flagDefaultValString > 0 {
		if s.defaultVal, err = p.parse(s.defaultValS); err != nil {
			return nil, err
		}
	}

	return s, nil
}

// Bool extracts and parses the variable provided according to the options provided.
func (c *Cfg) Bool(docOpts string, opts ...BoolOpt) bool {
	s, err := newBoolSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	v, _ := c.evaluate(s).(bool)
	return v
}

// Bool describes the configuration variable available
func (d *Describer) Bool(docOpts string, opts ...BoolOpt) (_ bool) {
	s, err := newBoolSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	d.describe(s)
	return
}

type DurationOpt interface {
	modifyDurationParser(p *durationParser) error
}

type durationOptFunc func(p *durationParser) error

func (f durationOptFunc) modifyDurationParser(p *durationParser) error {
	return f(p)
}

var _ DurationOpt = new(durationOptFunc)

func newDurationSpec(docOpts string, opts []DurationOpt) (*spec, error) {
	parsed, err := parseDocOpts(docOpts)
	if err != nil {
		return nil, err
	}

	os := make([]DurationOpt, 0, len(opts)+len(parsed))
	for _, p := range parsed {
		os = append(os, p)
	}

	p := new(durationParser)
	s := &spec{
		parser:   p,
		typeName: "time.Duration",
	}

	for _, opt := range append(os, opts...) {
		if opt, ok := opt.(interface{ modify(*spec) error }); ok {
			if err = opt.modify(s); err != nil {
				return nil, err
			}
			continue
		}
		if err := opt.modifyDurationParser(p); err != nil {
			return nil, err
		}
	}

	if s.flags&flagDefaultValString > 0 {
		if s.defaultVal, err = p.parse(s.defaultValS); err != nil {
			return nil, err
		}
	}

	return s, nil
}

// Duration extracts and parses the variable provided according to the options provided.
func (c *Cfg) Duration(docOpts string, opts ...DurationOpt) time.Duration {
	s, err := newDurationSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	v, _ := c.evaluate(s).(time.Duration)
	return v
}

// Duration describes the configuration variable available
func (d *Describer) Duration(docOpts string, opts ...DurationOpt) (_ time.Duration) {
	s, err := newDurationSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	d.describe(s)
	return
}

type FloatOpt interface {
	modifyFloatParser(p *floatParser) error
}

type floatOptFunc func(p *floatParser) error

func (f floatOptFunc) modifyFloatParser(p *floatParser) error {
	return f(p)
}

var _ FloatOpt = new(floatOptFunc)

func newFloatSpec(docOpts string, opts []FloatOpt) (*spec, error) {
	parsed, err := parseDocOpts(docOpts)
	if err != nil {
		return nil, err
	}

	os := make([]FloatOpt, 0, len(opts)+len(parsed))
	for _, p := range parsed {
		os = append(os, p)
	}

	p := new(floatParser)
	s := &spec{
		parser:   p,
		typeName: "float64",
	}

	for _, opt := range append(os, opts...) {
		if opt, ok := opt.(interface{ modify(*spec) error }); ok {
			if err = opt.modify(s); err != nil {
				return nil, err
			}
			continue
		}
		if err := opt.modifyFloatParser(p); err != nil {
			return nil, err
		}
	}

	if s.flags&flagDefaultValString > 0 {
		if s.defaultVal, err = p.parse(s.defaultValS); err != nil {
			return nil, err
		}
	}

	return s, nil
}

// Float extracts and parses the variable provided according to the options provided.
func (c *Cfg) Float(docOpts string, opts ...FloatOpt) float64 {
	s, err := newFloatSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	v, _ := c.evaluate(s).(float64)
	return v
}

// Float describes the configuration variable available
func (d *Describer) Float(docOpts string, opts ...FloatOpt) (_ float64) {
	s, err := newFloatSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	d.describe(s)
	return
}

type IntOpt interface {
	modifyIntParser(p *intParser) error
}

type intOptFunc func(p *intParser) error

func (f intOptFunc) modifyIntParser(p *intParser) error {
	return f(p)
}

var _ IntOpt = new(intOptFunc)

func newIntSpec(docOpts string, opts []IntOpt) (*spec, error) {
	parsed, err := parseDocOpts(docOpts)
	if err != nil {
		return nil, err
	}

	os := make([]IntOpt, 0, len(opts)+len(parsed))
	for _, p := range parsed {
		os = append(os, p)
	}

	p := new(intParser)
	s := &spec{
		parser:   p,
		typeName: "int64",
	}

	for _, opt := range append(os, opts...) {
		if opt, ok := opt.(interface{ modify(*spec) error }); ok {
			if err = opt.modify(s); err != nil {
				return nil, err
			}
			continue
		}
		if err := opt.modifyIntParser(p); err != nil {
			return nil, err
		}
	}

	if s.flags&flagDefaultValString > 0 {
		if s.defaultVal, err = p.parse(s.defaultValS); err != nil {
			return nil, err
		}
	}

	return s, nil
}

// Int extracts and parses the variable provided according to the options provided.
func (c *Cfg) Int(docOpts string, opts ...IntOpt) int64 {
	s, err := newIntSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	v, _ := c.evaluate(s).(int64)
	return v
}

// Int describes the configuration variable available
func (d *Describer) Int(docOpts string, opts ...IntOpt) (_ int64) {
	s, err := newIntSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	d.describe(s)
	return
}

type IntSliceOpt interface {
	modifyIntSliceParser(p *intSliceParser) error
}

type intSliceOptFunc func(p *intSliceParser) error

func (f intSliceOptFunc) modifyIntSliceParser(p *intSliceParser) error {
	return f(p)
}

var _ IntSliceOpt = new(intSliceOptFunc)

func newIntSliceSpec(docOpts string, opts []IntSliceOpt) (*spec, error) {
	parsed, err := parseDocOpts(docOpts)
	if err != nil {
		return nil, err
	}

	os := make([]IntSliceOpt, 0, len(opts)+len(parsed))
	for _, p := range parsed {
		os = append(os, p)
	}

	p := new(intSliceParser)
	s := &spec{
		parser:   p,
		typeName: "[]int64",
	}

	for _, opt := range append(os, opts...) {
		if opt, ok := opt.(interface{ modify(*spec) error }); ok {
			if err = opt.modify(s); err != nil {
				return nil, err
			}
			continue
		}
		if err := opt.modifyIntSliceParser(p); err != nil {
			return nil, err
		}
	}

	if s.flags&flagDefaultValString > 0 {
		if s.defaultVal, err = p.parse(s.defaultValS); err != nil {
			return nil, err
		}
	}

	return s, nil
}

// IntSlice extracts and parses the variable provided according to the options provided.
func (c *Cfg) IntSlice(docOpts string, opts ...IntSliceOpt) []int64 {
	s, err := newIntSliceSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	v, _ := c.evaluate(s).([]int64)
	return v
}

// IntSlice describes the configuration variable available
func (d *Describer) IntSlice(docOpts string, opts ...IntSliceOpt) (_ []int64) {
	s, err := newIntSliceSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	d.describe(s)
	return
}

type StringOpt interface {
	modifyStringParser(p *stringParser) error
}

type stringOptFunc func(p *stringParser) error

func (f stringOptFunc) modifyStringParser(p *stringParser) error {
	return f(p)
}

var _ StringOpt = new(stringOptFunc)

func newStringSpec(docOpts string, opts []StringOpt) (*spec, error) {
	parsed, err := parseDocOpts(docOpts)
	if err != nil {
		return nil, err
	}

	os := make([]StringOpt, 0, len(opts)+len(parsed))
	for _, p := range parsed {
		os = append(os, p)
	}

	p := new(stringParser)
	s := &spec{
		parser:   p,
		typeName: "string",
	}

	for _, opt := range append(os, opts...) {
		if opt, ok := opt.(interface{ modify(*spec) error }); ok {
			if err = opt.modify(s); err != nil {
				return nil, err
			}
			continue
		}
		if err := opt.modifyStringParser(p); err != nil {
			return nil, err
		}
	}

	if s.flags&flagDefaultValString > 0 {
		if s.defaultVal, err = p.parse(s.defaultValS); err != nil {
			return nil, err
		}
	}

	return s, nil
}

// String extracts and parses the variable provided according to the options provided.
func (c *Cfg) String(docOpts string, opts ...StringOpt) string {
	s, err := newStringSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	v, _ := c.evaluate(s).(string)
	return v
}

// String describes the configuration variable available
func (d *Describer) String(docOpts string, opts ...StringOpt) (_ string) {
	s, err := newStringSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	d.describe(s)
	return
}

type StringSliceOpt interface {
	modifyStringSliceParser(p *stringSliceParser) error
}

type stringSliceOptFunc func(p *stringSliceParser) error

func (f stringSliceOptFunc) modifyStringSliceParser(p *stringSliceParser) error {
	return f(p)
}

var _ StringSliceOpt = new(stringSliceOptFunc)

func newStringSliceSpec(docOpts string, opts []StringSliceOpt) (*spec, error) {
	parsed, err := parseDocOpts(docOpts)
	if err != nil {
		return nil, err
	}

	os := make([]StringSliceOpt, 0, len(opts)+len(parsed))
	for _, p := range parsed {
		os = append(os, p)
	}

	p := new(stringSliceParser)
	s := &spec{
		parser:   p,
		typeName: "[]string",
	}

	for _, opt := range append(os, opts...) {
		if opt, ok := opt.(interface{ modify(*spec) error }); ok {
			if err = opt.modify(s); err != nil {
				return nil, err
			}
			continue
		}
		if err := opt.modifyStringSliceParser(p); err != nil {
			return nil, err
		}
	}

	if s.flags&flagDefaultValString > 0 {
		if s.defaultVal, err = p.parse(s.defaultValS); err != nil {
			return nil, err
		}
	}

	return s, nil
}

// StringSlice extracts and parses the variable provided according to the options provided.
func (c *Cfg) StringSlice(docOpts string, opts ...StringSliceOpt) []string {
	s, err := newStringSliceSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	v, _ := c.evaluate(s).([]string)
	return v
}

// StringSlice describes the configuration variable available
func (d *Describer) StringSlice(docOpts string, opts ...StringSliceOpt) (_ []string) {
	s, err := newStringSliceSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	d.describe(s)
	return
}

type TimeOpt interface {
	modifyTimeParser(p *timeParser) error
}

type timeOptFunc func(p *timeParser) error

func (f timeOptFunc) modifyTimeParser(p *timeParser) error {
	return f(p)
}

var _ TimeOpt = new(timeOptFunc)

func newTimeSpec(docOpts string, opts []TimeOpt) (*spec, error) {
	parsed, err := parseDocOpts(docOpts)
	if err != nil {
		return nil, err
	}

	os := make([]TimeOpt, 0, len(opts)+len(parsed))
	for _, p := range parsed {
		os = append(os, p)
	}

	p := new(timeParser)
	s := &spec{
		parser:   p,
		typeName: "time.Time",
	}

	for _, opt := range append(os, opts...) {
		if opt, ok := opt.(interface{ modify(*spec) error }); ok {
			if err = opt.modify(s); err != nil {
				return nil, err
			}
			continue
		}
		if err := opt.modifyTimeParser(p); err != nil {
			return nil, err
		}
	}

	if s.flags&flagDefaultValString > 0 {
		if s.defaultVal, err = p.parse(s.defaultValS); err != nil {
			return nil, err
		}
	}

	return s, nil
}

// Time extracts and parses the variable provided according to the options provided.
func (c *Cfg) Time(docOpts string, opts ...TimeOpt) time.Time {
	s, err := newTimeSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	v, _ := c.evaluate(s).(time.Time)
	return v
}

// Time describes the configuration variable available
func (d *Describer) Time(docOpts string, opts ...TimeOpt) (_ time.Time) {
	s, err := newTimeSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	d.describe(s)
	return
}

type UintOpt interface {
	modifyUintParser(p *uintParser) error
}

type uintOptFunc func(p *uintParser) error

func (f uintOptFunc) modifyUintParser(p *uintParser) error {
	return f(p)
}

var _ UintOpt = new(uintOptFunc)

func newUintSpec(docOpts string, opts []UintOpt) (*spec, error) {
	parsed, err := parseDocOpts(docOpts)
	if err != nil {
		return nil, err
	}

	os := make([]UintOpt, 0, len(opts)+len(parsed))
	for _, p := range parsed {
		os = append(os, p)
	}

	p := new(uintParser)
	s := &spec{
		parser:   p,
		typeName: "uint64",
	}

	for _, opt := range append(os, opts...) {
		if opt, ok := opt.(interface{ modify(*spec) error }); ok {
			if err = opt.modify(s); err != nil {
				return nil, err
			}
			continue
		}
		if err := opt.modifyUintParser(p); err != nil {
			return nil, err
		}
	}

	if s.flags&flagDefaultValString > 0 {
		if s.defaultVal, err = p.parse(s.defaultValS); err != nil {
			return nil, err
		}
	}

	return s, nil
}

// Uint extracts and parses the variable provided according to the options provided.
func (c *Cfg) Uint(docOpts string, opts ...UintOpt) uint64 {
	s, err := newUintSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	v, _ := c.evaluate(s).(uint64)
	return v
}

// Uint describes the configuration variable available
func (d *Describer) Uint(docOpts string, opts ...UintOpt) (_ uint64) {
	s, err := newUintSpec(docOpts, opts)
	if err != nil {
		panic(err)
	}
	d.describe(s)
	return
}
