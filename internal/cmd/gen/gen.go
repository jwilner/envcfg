package main

import (
	"bytes"
	"go/format"
	"html/template"
	"io"
	"log"
	"os"
	"sort"
	"unicode"
)

type specCfg struct {
	MethodName, TypeName, ParamsName string
	Imports                          []string
}

func (s specCfg) MethodNameLower() string {
	runes := []rune(s.MethodName)
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}

func (s specCfg) ParamsNameExported() string {
	runes := []rune(s.ParamsName)
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

var (
	types = []specCfg{
		{"Bool", "bool", "boolParser", nil},
		{"Duration", "time.Duration", "durationParser", []string{"time"}},
		{"Float", "float64", "floatParser", nil},
		{"Int", "int64", "intParser", nil},
		{"IntSlice", "[]int64", "intSliceParser", nil},
		{"String", "string", "stringParser", nil},
		{"StringSlice", "[]string", "stringSliceParser", nil},
		{"Time", "time.Time", "timeParser", []string{"time"}},
		{"Uint", "uint64", "uintParser", nil},
	}
	tmpl = template.Must(template.New("").Parse(`
// Code generated by internal/cmd/gen/gen.go DO NOT EDIT.
package envcfg

import (
{{ range $i := .Imports -}}
     "{{ . }}"
{{ end }}
)

type Configurer interface {
	Has(s string) bool
	HasNot(s string) bool
{{ range $t := .Types -}}
	{{ .MethodName }}(docOpts string, opts ...{{ .MethodName }}Opt) {{ .TypeName }}
{{ end }}
}

type UniOpt interface {
	modify(s *spec) error
{{ range $t := .Types -}}
	modify{{ .ParamsNameExported }}(p *{{ .ParamsName }}) error 
{{ end }}
}

type uniOptFunc func(s *spec) error

func (f uniOptFunc) modify(s *spec) error {
	return f(s)
}

{{ range $t := .Types }}
func (uniOptFunc) modify{{ .ParamsNameExported }}(p *{{ .ParamsName }}) error {
	return nil
} 
{{ end }}

var _ UniOpt = new(uniOptFunc)

{{ range $t := .Types }}
type {{ .MethodName }}Opt interface {
	modify{{ .ParamsNameExported }}(p *{{ .ParamsName }}) error
}

type {{ .MethodNameLower }}OptFunc func(p *{{ .ParamsName }}) error

func (f {{ .MethodNameLower }}OptFunc) modify{{ .ParamsNameExported }}(p *{{ .ParamsName }}) error {
	return f(p)
}

var _ {{ .MethodName }}Opt = new({{ .MethodNameLower }}OptFunc)

func new{{ .MethodName }}Spec(docOpts string, opts []{{ .MethodName }}Opt) (*spec, error) {
	parsed, err := parseDocOpts(docOpts)
	if err != nil {
		return nil, err
	}

	os := make([]{{ .MethodName }}Opt, 0, len(opts) + len(parsed))
	for _, p := range parsed {
		os = append(os, p)
	}

	p := new({{ .ParamsName }})
    s := &spec{
		parser: p,
		typeName: "{{ .TypeName }}",
	}

    for _, opt := range append(os, opts...) {
		if opt, ok := opt.(interface { modify(*spec) error }); ok {
			if err = opt.modify(s); err != nil {
				return nil, err
			}
			continue
		}
		if err := opt.modify{{ .ParamsNameExported }}(p); err != nil {
			return nil, err
		}
    }
	
	if s.flags & flagDefaultValString > 0 {
		if s.defaultVal, err = p.parse(s.defaultValS); err != nil {
			return nil, err
		}
	}

	return s, nil
}

// {{ .MethodName }} extracts and parses the variable provided according to the options provided.
func (c *Cfg) {{ .MethodName }}(docOpts string, opts ...{{ .MethodName }}Opt) {{ .TypeName }} {
    s, err := new{{ .MethodName }}Spec(docOpts, opts)
	if err != nil {
		panic(err)
    }
	v, _ := c.evaluate(s).({{ .TypeName }})
	return v
}

// {{ .MethodName }} describes the configuration variable available
func (d *Describer) {{ .MethodName }}(docOpts string, opts ...{{ .MethodName }}Opt) (_ {{ .TypeName }}) {
	s, err := new{{ .MethodName }}Spec(docOpts, opts)
	if err != nil {
		panic(err)
    }
	d.describe(s)
	return
}
{{ end }}
`))
)

func main() {
	cfg := struct {
		Types   []specCfg
		Imports []string
	}{
		Types:   types,
		Imports: []string{},
	}

	seen := make(map[string]bool)
	for _, t := range cfg.Types {
		for _, i := range t.Imports {
			if !seen[i] {
				seen[i] = true
				cfg.Imports = append(cfg.Imports, i)
			}
		}
	}

	sort.Strings(cfg.Imports)

	var b bytes.Buffer
	if err := tmpl.Execute(&b, cfg); err != nil {
		log.Fatal(err)
	}

	res, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	if _, err := io.Copy(os.Stdout, bytes.NewReader(res)); err != nil {
		log.Fatal(err)
	}
}
