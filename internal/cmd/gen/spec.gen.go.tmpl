// Code generated by internal/cmd/gen/gen.go DO NOT EDIT.
package envcfg
{{/* gotype: github.com/jwilner/envcfg/internal/cmd/gen.specCfg */}}
{{ if .Imports -}}
import (
{{ range .Imports -}}
     "{{ . }}"
{{ end }}
)
{{ end }}

// {{ .MethodName }} extracts and parses the variable provided according to the options provided.
// Available options:
{{ range .Options -}}
{{ if .Global -}}
// - "{{ .Name | snake_case }}" or {{ .Name }}
{{ else -}}
// - "{{ .Name | snake_case }}" or {{ $.MethodName }}.{{ .Name }}
{{ end -}}
{{ end -}}
func (c *Cfg) {{ .MethodName }}(docOpts string, opts ...{{ .OptName }}) (v {{ .TypeName }}) {
    s, err := new{{ .MethodName }}Spec(docOpts, opts)
	if err != nil {
		if c.panic {
			panic(err)
		}
		c.addError(err)
		return
    }
	c.addDescription(s.describe())
	v, _ = c.evaluate(s).({{ .TypeName }})
	return
}

// {{ .OptName }} modifies {{ .MethodName }} variable configuration.
type {{ .OptName }} interface {
	modify(s *spec)
	modify{{ .ParserName }}(p *{{ .ParserName | unexported }})
}

var {{ .MethodName }} = struct {
{{ range .LocalOptions -}}
	{{ .Name }} func({{ .Type }}) {{ $.OptName }}
{{ end -}}
}{
{{ range .LocalOptions -}}
{{ if eq .Name "Default" -}}
	Default: func(def {{ $.TypeName }}) {{ $.OptName }} {
		return defaultOpt(def)
	},
{{ else -}}
	{{ .Name }}: func({{ .Name | unexported }} {{ .Type }}) {{ $.OptName }} {
		return {{ $.OptName | unexported }}Func(func(p *{{ $.ParserName | unexported }}) {
			p.{{ .Name | unexported }} = {{ .Name | unexported }}
		})
	},
{{ end -}}
{{ end -}}
}

type {{ .OptName | unexported }}Func func(p *{{ .ParserName | unexported }})

func (f {{ .OptName | unexported }}Func) modify{{ .ParserName }}(p *{{ .ParserName | unexported }}) {
	f(p)
}

func ({{ .OptName | unexported }}Func) modify(*spec) {}

var _ {{ .OptName }} = new({{ .OptName | unexported }}Func)

func new{{ .MethodName }}Spec(docOpts string, opts []{{ .OptName }}) (*spec, error) {
	parsed, err := parse(docOpts)
	if err != nil {
		return nil, err
	}

	p := new({{ .ParserName | unexported }})
    s := &spec{
		parser: p,
		typeName: "{{ .TypeName }}",
		name: parsed.name,
		comment: parsed.description,
	}

	for _, f := range parsed.fields {
		var (
			opt {{ .OptName }}
			err error
		)
		switch strings.ToLower(f[0]) {
{{ range .Options -}}
		case "{{ .Name | snake_case }}":
{{ if eq .Name "Default" -}}
			val := f[1]
			opt = uniOptFunc(func(s *spec) {
				s.flags |= flagDefaultValString | flagDefaultVal
				s.defaultValS = val
			})
{{ else if eq .Name "Optional" -}}
			if f[1] != "" {
				err = errors.New("optional does not take any arguments")
			}
			opt = Optional
{{ else if eq .Type "bool" -}}
			var val bool
			val, err = strconv.ParseBool(f[1])
			opt = {{ $.MethodName }}.{{ .Name }}(val)
{{ else if eq .Type "int" -}}
			var val int
			val, err = strconv.Atoi(f[1])
			opt = {{ $.MethodName }}.{{ .Name }}(val)
{{ else if eq .Type "rune" -}}
			value := []rune(f[1])
			if len(value) != 1 {
				err = errors.New("must be only one rune")
				break
			}
			opt = {{ $.MethodName }}.{{ .Name }}(value[0])
{{ else if eq .Type "string" }}
			opt = {{ $.MethodName }}.{{ .Name }}(f[1])
{{ end -}}
{{ end -}}
		}
		if err != nil {
			return nil, err
		}
		if opt == nil {
			return nil, errors.New("unknown")
		}
		opt.modify(s)
		opt.modify{{ .ParserName }}(p)
	}

    for _, opt := range opts {
		opt.modify(s)
		opt.modify{{ .ParserName }}(p)
    }

	if s.flags & flagDefaultValString > 0 {
		if s.defaultVal, err = p.parse(s.defaultValS); err != nil {
			return nil, err
		}
	}

	return s, nil
}

type {{ .ParserName | unexported }} struct {
{{ range $o := .Fields -}}
	{{ .Name | unexported}} {{ .Type }}
{{ end -}}
}

func (p *{{ .ParserName | unexported }}) parse(s string) (interface{}, error) {
{{ if .Slice -}}
{{ if not .ParseFunc -}}
	return parseSlice(s, p.comma)
{{ else -}}
	ses, err := parseSlice(s, p.comma)
	if err != nil {
		return nil, err
	}
	{{ range .ParseParams -}}
	{{ if .Default }}
	{{ .Name | unexported }} := p.{{ .Name | unexported }}
	if {{ .Name | unexported }} == {{ .ZeroVal }} {
		{{ .Name | unexported }} = {{ .Default }}
	}
	{{ end }}
	{{ end -}}
	vals := make({{ .TypeName }}, len(ses))
	for i, v := range ses {
		el, err := {{ .ParseFunc }}(
			{{ range .ParseParams -}}
			{{ if .Name }}{{ if not .Default }}p.{{ end }}{{ .Name | unexported }}{{ else }}v{{ end }},
			{{ end -}}
		)
		if err != nil {
			return nil, fmt.Errorf("%v index: %v", i, err)
		}
		vals[i] = el
	}
	return vals, nil
{{ end }}
{{ else -}}
{{ if not .ParseFunc -}}
	return s, nil
{{ else -}}
	{{ range .ParseParams -}}
	{{ if .Default -}}
	{{ .Name | unexported }} := p.{{ .Name | unexported }}
	if {{ .Name | unexported }} == {{ .ZeroVal }} {
		{{ .Name | unexported }} = {{ .Default }}
	}
	{{ end -}}
	{{ end -}}
	return {{ .ParseFunc }}(
{{ range .ParseParams -}}
		{{ if .Name -}}{{ if not .Default }}p.{{ end }}{{ .Name | unexported }}{{ else -}}s{{ end -}},
{{ end -}}
	)
{{ end -}}
{{ end -}}
}

func (p *{{ .ParserName | unexported }}) describe() interface{} {
	{{ if .Fields -}}
	return {{ .ParserName | unexported }}Description {
{{ range .Fields -}}
		{{ .Name }}: p.{{ .Name | unexported }},
{{ end -}}
	}
	{{ else -}}
	return struct{}{}
	{{ end -}}
}

{{ if .Fields -}}
type {{ .ParserName | unexported }}Description struct{
{{ range .Fields -}}
		{{ .Name }} {{ .Type }} `json:"{{ .Name | snake_case }},omitempty"`
{{ end -}}
}
{{ if .CustomJSON }}
func (d {{ .ParserName | unexported }}Description ) MarshalJSON() ([]byte, error) {
{{ range .Fields -}}
{{ if eq .Type "rune" -}}
	var {{ .Name | unexported }} string
	if d.{{ .Name }} != 0 {
		{{ .Name | unexported }} = string(d.{{ .Name }})
	}
{{ end -}}
{{ end -}}
	return json.Marshal(struct {
{{ range .Fields -}}
{{ if eq .Type "rune" -}}
		{{ .Name }} string `json:"{{ .Name | snake_case }},omitempty"`
{{ else -}}
		{{ .Name }} {{ .Type }} `json:"{{ .Name | snake_case }},omitempty"`
{{ end -}}
{{ end -}}
	} {
{{ range .Fields -}}
{{ if eq .Type "rune" -}}
		{{ .Name }}: {{ .Name | unexported }},
{{ else -}}
		{{ .Name }}: d.{{ .Name }},
{{ end -}}
{{ end -}}
	})
}
{{ end -}}
{{ end -}}
