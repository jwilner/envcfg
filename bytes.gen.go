// Code generated by internal/cmd/gen/gen.go DO NOT EDIT.
package envcfg

import (
	"encoding/json"
	"errors"
	"strconv"
	"strings"
)

// Bytes extracts and parses the variable provided according to the options provided.
// Available options:
// - default
// - no_padding
// - optional
// - padding
// - url_safe
func (c *Cfg) Bytes(docOpts string, opts ...BytesOpt) (v []byte) {
	s, err := newBytesSpec(docOpts, opts)
	if err != nil {
		if c.panic {
			panic(err)
		}
		c.addError(err)
		return
	}
	c.addDescription(s.describe())
	v, _ = c.evaluate(s).([]byte)
	return
}

// BytesOpt modifies Bytes variable configuration.
type BytesOpt interface {
	modify(s *spec)
	modifyBytesParser(p *bytesParser)
}

var Bytes = struct {
	Default   func([]byte) BytesOpt
	NoPadding func(bool) BytesOpt
	Padding   func(rune) BytesOpt
	URLSafe   func(bool) BytesOpt
}{
	Default: func(def []byte) BytesOpt {
		return defaultOpt(def)
	},
	NoPadding: func(noPadding bool) BytesOpt {
		return bytesOptFunc(func(p *bytesParser) {
			p.setNoPadding(noPadding)
		})
	},
	Padding: func(padding rune) BytesOpt {
		return bytesOptFunc(func(p *bytesParser) {
			p.setPadding(padding)
		})
	},
	URLSafe: func(urlSafe bool) BytesOpt {
		return bytesOptFunc(func(p *bytesParser) {
			p.setURLSafe(urlSafe)
		})
	},
}

type bytesOptFunc func(p *bytesParser)

func (f bytesOptFunc) modifyBytesParser(p *bytesParser) {
	f(p)
}

func (bytesOptFunc) modify(*spec) {}

var _ BytesOpt = new(bytesOptFunc)

func newBytesSpec(docOpts string, opts []BytesOpt) (*spec, error) {
	parsed, err := parse(docOpts)
	if err != nil {
		return nil, err
	}

	p := new(bytesParser)
	s := &spec{
		parser:   p,
		typeName: "[]byte",
		name:     parsed.name,
		comment:  parsed.description,
	}

	for _, f := range parsed.fields {
		var (
			opt BytesOpt
			err error
		)
		switch strings.ToLower(f[0]) {
		case "default":
			val := f[1]
			opt = uniOptFunc(func(s *spec) {
				s.flags |= flagDefaultValString | flagDefaultVal
				s.defaultValS = val
			})
		case "no_padding":
			var val bool
			val, err = strconv.ParseBool(f[1])
			opt = Bytes.NoPadding(val)
		case "optional":
			if f[1] != "" {
				err = errors.New("optional does not take any arguments")
			}
			opt = Optional
		case "padding":
			value := []rune(f[1])
			if len(value) != 1 {
				err = errors.New("must be only one rune")
				break
			}
			opt = Bytes.Padding(value[0])
		case "url_safe":
			var val bool
			val, err = strconv.ParseBool(f[1])
			opt = Bytes.URLSafe(val)
		}
		if err != nil {
			return nil, err
		}
		if opt == nil {
			return nil, errors.New("unknown")
		}
		opt.modify(s)
		opt.modifyBytesParser(p)
	}

	for _, opt := range opts {
		opt.modify(s)
		opt.modifyBytesParser(p)
	}

	if s.flags&flagDefaultValString > 0 {
		if s.defaultVal, err = p.parse(s.defaultValS); err != nil {
			return nil, err
		}
	}

	return s, nil
}

type bytesParser struct {
	padding   rune
	noPadding bool
	urlSafe   bool
}

func (p *bytesParser) setPadding(padding rune) {
	p.padding = padding
}

func (p *bytesParser) setNoPadding(noPadding bool) {
	p.noPadding = noPadding
}

func (p *bytesParser) setURLSafe(urlSafe bool) {
	p.urlSafe = urlSafe
}

func (p *bytesParser) parse(s string) (interface{}, error) {
	return parseBytes(
		s,
		p.padding,
		p.noPadding,
		p.urlSafe,
	)
}

func (p *bytesParser) describe() interface{} {
	return bytesParserDescription{
		Padding:   p.padding,
		NoPadding: p.noPadding,
		URLSafe:   p.urlSafe,
	}
}

type bytesParserDescription struct {
	Padding   rune `json:"padding,omitempty"`
	NoPadding bool `json:"no_padding,omitempty"`
	URLSafe   bool `json:"url_safe,omitempty"`
}

func (d bytesParserDescription) MarshalJSON() ([]byte, error) {
	var padding string
	if d.Padding != 0 {
		padding = string(d.Padding)
	}
	return json.Marshal(struct {
		Padding   string `json:"padding,omitempty"`
		NoPadding bool   `json:"no_padding,omitempty"`
		URLSafe   bool   `json:"url_safe,omitempty"`
	}{
		Padding:   padding,
		NoPadding: d.NoPadding,
		URLSafe:   d.URLSafe,
	})
}
