// Code generated by internal/cmd/gen/gen.go DO NOT EDIT.
package envcfg

import (
	"encoding/json"
	"fmt"
	"strconv"
)

type IntSliceOpt interface {
	modifyIntSliceParser(p *intSliceParser) error
}

// IntSlice extracts and parses the variable provided according to the options provided.
// Available options:
// - base
// - bit_size
// - comma
// - default
func (c *Cfg) IntSlice(docOpts string, opts ...IntSliceOpt) []int64 {
	s, err := newIntSliceSpec(docOpts, opts)
	if err != nil {
		if c.panic {
			panic(err)
		}
		c.addError(err)
	}
	c.addDescription(s.describe())
	v, _ := c.evaluate(s).([]int64)
	return v
}

var IntSlice = struct {
	Default func([]int64) IntSliceOpt
	Base    func(int) IntSliceOpt
	BitSize func(int) IntSliceOpt
	Comma   func(rune) IntSliceOpt
}{
	Default: func(def []int64) IntSliceOpt {
		return defaultOpt(def)
	},
	Base: func(base int) IntSliceOpt {
		return intSliceOptFunc(func(p *intSliceParser) error {
			p.setBase(base)
			return nil
		})
	},
	BitSize: func(bitSize int) IntSliceOpt {
		return intSliceOptFunc(func(p *intSliceParser) error {
			p.setBitSize(bitSize)
			return nil
		})
	},
	Comma: func(comma rune) IntSliceOpt {
		return intSliceOptFunc(func(p *intSliceParser) error {
			p.setComma(comma)
			return nil
		})
	},
}

type intSliceOptFunc func(p *intSliceParser) error

func (f intSliceOptFunc) modifyIntSliceParser(p *intSliceParser) error {
	return f(p)
}

var _ IntSliceOpt = new(intSliceOptFunc)

func newIntSliceSpec(docOpts string, opts []IntSliceOpt) (*spec, error) {
	parsed, err := parseDocOpts(docOpts)
	if err != nil {
		return nil, err
	}

	os := make([]IntSliceOpt, 0, len(opts)+len(parsed))
	for _, p := range parsed {
		os = append(os, p)
	}

	p := new(intSliceParser)
	s := &spec{
		parser:   p,
		typeName: "[]int64",
	}

	for _, opt := range append(os, opts...) {
		if opt, ok := opt.(interface{ modify(*spec) error }); ok {
			if err = opt.modify(s); err != nil {
				return nil, err
			}
			continue
		}
		if err := opt.modifyIntSliceParser(p); err != nil {
			return nil, err
		}
	}

	if s.flags&flagDefaultValString > 0 {
		if s.defaultVal, err = p.parse(s.defaultValS); err != nil {
			return nil, err
		}
	}

	return s, nil
}

type intSliceParser struct {
	baser
	bitSizer
	slicer
}

func (p *intSliceParser) parse(s string) (interface{}, error) {
	ses, err := p.parseSlice(s)
	if err != nil {
		return nil, err
	}

	vals := make([]int64, len(ses))
	for i, v := range ses {
		el, err := strconv.ParseInt(
			v,
			p.base,
			p.bitSize,
		)
		if err != nil {
			return nil, fmt.Errorf("%v index: %v", i, err)
		}
		vals[i] = el
	}
	return vals, nil

}

func (p *intSliceParser) describe() interface{} {
	return intSliceParserDescription{
		Base:    p.base,
		BitSize: p.bitSize,
		Comma:   p.comma,
	}
}

type intSliceParserDescription struct {
	Base    int  `json:"base,omitempty"`
	BitSize int  `json:"bit_size,omitempty"`
	Comma   rune `json:"comma,omitempty"`
}

func (d intSliceParserDescription) MarshalJSON() ([]byte, error) {
	var comma string
	if d.Comma != 0 {
		comma = string(d.Comma)
	}
	return json.Marshal(struct {
		Base    int    `json:"base,omitempty"`
		BitSize int    `json:"bit_size,omitempty"`
		Comma   string `json:"comma,omitempty"`
	}{
		Base:    d.Base,
		BitSize: d.BitSize,
		Comma:   comma,
	})
}
